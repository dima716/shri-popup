<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" href="popup.css">
</head>
<body>
<h1>Верстка всплывающего окна (попап)</h1>
<p>Верстка всплывающего окна, как минимум, включает себя два следующих шага:</p> <p>1) Создание затемняющего наложения, которое будет находиться позади всплывающего окна и обозначать неактивность остальной части страницы.</p> <p>2) Отображение всплывающего окна в определенном месте на странице.</p></p>

<p>По заданию необходимо, чтобы окно всегда находилось посередине.
Исходя из этого рассмотрим несколько способов затемнения части страницы, которая находится позади попапа, а также несколько способов центрирования попапа.</p>

<h2>Способы создания затемняющего наложения</h2>
<h3>Способ №1. Элемент с position: absolute</h3>
 <p>Данный способо подразумевает создания абсолютно спозиционнированного контейнера, которому задается z-index больше, чем у других элементов страницы, но меньше, чем у всплывающего окна.</p>

<p>Реализация данного примера:</p>

<p data-height="400" data-theme-id="8671" data-slug-hash="LGJBq" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/LGJBq/'>Creating an Overlay on Element with position:fixed</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Поддерживается в большинстве современных браузеров, вклчае IE => 8.</p>
<p class="cons">Необходимо всегда точно знать, что элемент попап абсолютно спозиционирован по отношению к элементу body. Иначе, если попап находится внутри другого контейнера с position:relative, абсолютное позициирование будет применяться к нему, и наложение будет работать неправильно. Чтобы этого избежать, необходимо сделать элемент попап прямым потомком элемента body, либо удостовериться, что ни один из предков элемента попап не имееет position: relative</p>
<p class="cons">Если контента страницы не достаточно, чтобы элемент body растянулся по высоте до низа viewport, то контейнер с наложением
,которому задается height: 100% относительно высоты элемента body не растянется по всей высоте viewport, и соответственно затемняться будет не вся страница. Чтобы это исправить, необходимо задать height: 100%, элементу html и элементу body, тогда высота этиъ элементов, а соответственно и высота контейнера с наложением всегда будет равняться высоте viewport.</p>
<p>Однако в данном случае, при скролле страницы, наложение не будет распространяться на контент расположенный ниже. Решением в этой ситуации будет задание элементам html и body свойства min-height: 100% и элементу body свойства position:relative. Таким образом контейнер с наложением будет принмать высоту viewport и растягиваться при добавлении контента.</p>
<p class="cons">Добавляется пустой контейнер в разметку, что нарушает семантичность кода.</p>

<h3>Способ №2. Элемент с position: fixed</h3>
<p>Данный способ практически не отличается от описанного выше, за исключением того, что контейнеру с наложением задается position:fixed.</p>
<p>Реализация данного примера:</p>
<p data-height="399" data-theme-id="8671" data-slug-hash="EKhks" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/EKhks/'>Creating an Overlay on Element with position:fixed</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Контейнер с наложением в данном случае позиционируется  <b>фиксированно</b> по отношению к viweport, поэтому не важно где в DOM будет находиться данный элемент, он всегда будет позиционирован относительно viweport</p>
<p class="pros">По этой же причине скролл никак не будет влиять на отоборажение контейнера с наложением, оно всегда будет фиксированно.</p>
<p class="cons">
Если одному из предков контейнера с наложением задать свойство transition, то в результате все дочерние блоки, даже те у которых position:fixed, позиционируются относительно данного предка, что соответсвенно нарушает работу контейнера с наложением.
</p>
<p class="cons">
Как и в предыдущем способе добавляется пустой контейнер в разметку, что нарушает семантичность кода.
</p>

<h3>Способ №3. Использование псевдоэлемента</h3>
<p>В данном способе применяются те же css правила, что и в предыдущих способах, но не к контейнеру, а к псевдоэлементам :after и :before элмента body.</p>
<p>Реализация данного примера:</p>
<p data-height="400" data-theme-id="8671" data-slug-hash="tzkdD" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/tzkdD/'>Creating an Overlay with pseudoelement</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Не нарушается семантичность разметки, т.к. не используется отдельный контейнер.</p>

<p class="cons">
Некоторые версии современных браузеров не поддерживают css transitions для псевдоэлементов, не позволяя таким образом задавать плавное появление попапов. Например, Chrome поддерживает  css transitions для псевдоэлементов, начиная с версии 26, Safari только начиная с версии 6. (Данные с caniuse.com)
</p>


<h3>Способ №4. Применение свойства outline к всплывающему окну</h3>
<p>В данном способе не создается дополнительных контейнеров для наложения, а задается свойство outline c достаточно большим значением для самого попапа. Значение свойства outline должно быть таким, чтобы покрыывать всю область viewport.</p>

<p>Реализация данного примера:</p>
<p data-height="400" data-theme-id="8671" data-slug-hash="nasEi" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/nasEi/'>Creating an Overlay on Element with position:fixed</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Не нарушается семантичность разметки, т.к. не используется отдельный контейнер.</p>

<p class="cons">
При применении данного способа, контент, который находится позади всплывающего окна, остается активным, т.е если, например, на какой - либо элемент повешен обработчик события клика, то при нажатии он сработает.
</p>

<p class="cons">
Свойство outline элемента отрисовывается вне свойства border, и поэтому при применении свойства border-radius могут появиться нежелательные промежутки в которых будет отображаться контент, находящийся позади попапа.
</p>

<p class="cons">
Некоторые версии Firefox отрисовывают outline вне свойства margin
</p>


<h3>Способ №5. Применение свойства box-shadow к всплывающему окну</h3>
<p>Данный способ повторяет предыдущий, только вместо свойства outline 
испольузуется свойство box-shadow</p>
<p>Реализация данного примера:</p>
<p data-height="400" data-theme-id="8671" data-slug-hash="kCicH" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/kCicH/'>Creating an Overlay with box-shadow</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Не нарушается семантичность разметки, т.к. не используется отдельный контейнер.</p>

<p class="cons">
Как и в предыдущем способе, контент, который находится позади всплывающего окна, остается активным.
</p>

<p class="cons">
Главный недостаток давного способоа заключается в том, свойство box-shadow в сочетании с другими css правилами, такими как border-radius, могут стать теми уязвимыми местами, которые приводят к потере <a target="_blank" href="http://makandracards.com/makandra/17609-many-box-shadows-will-make-your-app-unusable-on-smartphones-and-tablets">производительности</a> на смартфонах и планшетах. Особенно это становится заметно при применении box-shadow c большим значением к элементам с position:fixed, т.к в этом случае оно заставляет браузер перерисовать большие области страницы при скролле.
</p>

<p class="cons">
Свойство box-shadow не поддерживается в ie <= 8.
</p>

<h3>Способ №6. Применение html элемента &lt;dialog&gt;</h3>
<p>Данный элемент появился достаточно недавно, и к сожалению поддерживается в очень <a href="http://caniuse.com/#search=dialog" target="_blank">ограниченном</a> количествое браузеров.

<p>Данный элемент позволяет легко создавать и стилизовать всплывающие окна. Он предоставляет всю небходимую функциональность модальных окон. Данный элемент находится в DOM и может стилизоваться путем применения обычных css правил</p>

<p>Реализация данного примера в Chrome версии => 37 :</p>

<dialog>
  <p>Я модальное окно!</p>
  <button class="btn close">Закрыть</button>
</dialog>
<button class="btn show">Открыть!</button>

<p class="pros">Из всех способов это самый семантичный, т.к. данный элемент предназначен именно для создания диалоговых окон. Таким образом, поисковые роботы и программы типа screen readers будут правильно интерпритировать данный элемент при анализе сайта, что
также увеличивает его Web Accessibility.</p>

<p class="pros">
    Диалоговое окно можно сделать модальным, т.е. при открытии блокировать остальной документ.
</p>

<p class="pros">
    Не нужно задавать свойство z-index, т.к. элемент &lt;dialog&gt; создается в новом слое, который накладывается поверх других слоев, в которых находятся остальные элементы страницы
</p>

<p class="pros">С элементом &lt;dialog&gt; связан псевдоэлемент 
::backdrop, который позволяет легко задать стиль для бэкграунда, находящегося позади всплывающего окна. Именно с помощью его можно сделать затемнение как в предыдущих способах.</p>

<p class="cons">
Крайне ограниченная поддержка браузерами!
</p>


<h2>Способы центрирования всплывающего окна</h2>
<h3>Способ №1. Применение свойства transform </h3>
<p>Данный способ подразумевает сдвиг элемента на 50%, используя свойства top и left, и сдвига элемента влево и вверх на половину ширины и высоты путем задания свойства transform:translate(-50%,-50%)
</p>

<p>Реализация данного примера:</p>

<p data-height=400 data-theme-id="8671" data-slug-hash="IqyGb" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/IqyGb/'>Centering an Overlay with transform</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Для центрирования не требуется знания высоты и ширины попапа. </p>
<p class="cons">Данное свойство не поддерживается в IE8, в остальных браузерах необходимо использовать вендорные префиксы.</p>


<h3>Способ №2. Применение javascript</h3>
<p>Центрирование элемента происходит путем написания кода в javascript,
который вычисляет текущую высоту и ширину элемента и задает соответствующие отрицательные margin-left и margin-top.</p>
<p>Реализация данного примера:</p>
<p data-height="400" data-theme-id="8671" data-slug-hash="uwnAy" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/uwnAy/'>Centering an Overlay with javascript</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Как и в предыдущем примере для центрирования не требуется знания высоты и ширины попапа. </p>

<p class="cons">
Данный способ не работает если у пользователя отключен javascript.
</p>

<p class="cons">
При задании отрицательных margin-left и margin-top нужно удостовериться, что у попапа задано свойство box-sizing:border-box, которое включает padding и border при расчете высоты и ширины элемента. Либо необходимо переписать javascript для их учета.
</p>

<h3>Способ №3. Применение свойства vertical-align</h3>
<p>Данный способ можно применять, если попап помещен в контейнер с наложением. Он заключается в том, что перед центрируемым элементом помещается вспомогательный инлайн-блок before, занимающий всю возможную высоту и центрируемый блок выравнивается по его середине. Выравнивание по горизонтали происходит за счет задания внешнему блоку
text-align:center</p>
<p>Реализация данного примера:</p>
<p data-height="400" data-theme-id="8671" data-slug-hash="pBJvr" data-default-tab="result" data-user="dima716" class='codepen'>See the Pen <a href='http://codepen.io/dima716/pen/pBJvr/'>Centering an Overlay with vertical-align and pseudoelement</a> by Dmitry (<a href='http://codepen.io/dima716'>@dima716</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>

<p class="pros">Как и в предыдущем примере для центрирования не требуется знания высоты и ширины попапа.</p>

<p class="pros">Достаточно универсальное решение, поддерживается в ie => 8</p>

<p class="cons">
В данном случае в разметке присутствует внешний контейнер.
</p>

<p class="cons">
Т.к. попапу задается display:inline-block и он ведет себя как инлайновый элемент, то из-за наличия пробелов он не центрируется ровно по горизонтали. Поэтому необходимо убирать пробелы в html коде или задать отрицательный margin-left попапу.
</p>


<h2>Выводы</h2>

<p>Из всех рассмотренных способов создания наложения, наиболее приемлемым, на мой взгляд, является применение способа с использованием
псевдоэлемента, т.к. он не требует создания лишних элементов в разметке и поддерживается в IE => 8.</p>

<p>Для центрирования попапа на странице, если известны высота и ширина, я бы использовал top:50% и left:50% и задание отрицательных 
margin-left и margin-top. Если нет, то javascript, т.к. transform:translate не поддерживается в IE 8. При описании способов не были</p>

<p>Если для создания наложения используется отдельный блок, а не псевдоэлемент элемента body, то для центрирования попапа можно использовать способ №3.
</p>






<script src="popup.js"></script>
</body>
</html>